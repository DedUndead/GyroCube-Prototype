#include <stdio.h>
#include "sensor/Accelerometer.h"
#include "interface/i2c.h"

Accelerometer::Accelerometer(I2C* i2c_, uint8_t address_) :
    fast_mode(false),
    address(address_),
    i2c(i2c_) 
{ /* Empty constructor budy */ }

/**
 * @brief Read sensor data
 * @param acc_measurement Buffer to read the data to
 * @return 0 on success, otherwise error status
 */
int Accelerometer::read(acc_measurements& buffer)
{
    if (fetch_data() < XYZ_BUFFER) {
        return ACC_ERROR_STATUS;
    }
    
    // Save data to buffer
    if (fast_mode) {
        printf("Raw reading: %d %d %d\n", buffer_short[0], buffer_short[1], buffer_short[2]);
        buffer.x = static_cast<int16_t>(buffer_short[0] << 6) * SCALE_FACTOR;
        buffer.y = static_cast<int16_t>(buffer_short[1] << 6) * SCALE_FACTOR;
        buffer.z = static_cast<int16_t>(buffer_short[2] << 6) * SCALE_FACTOR;
    }
    else {
        uint16_t x_raw = (buffer_full[0] << 6) | (buffer_full[1] >> 2);
        buffer.x = static_cast<int16_t>(x_raw) * SCALE_FACTOR;

        uint16_t y_raw = (buffer_full[2] << 6) | (buffer_full[3] >> 2);
        buffer.y = static_cast<int16_t>(y_raw) * SCALE_FACTOR;

        uint16_t z_raw = (buffer_full[4] << 6) | (buffer_full[5] >> 2);
        buffer.z = static_cast<int16_t>(z_raw) * SCALE_FACTOR;

        printf("Raw reading: %d %d %d\n", x_raw, y_raw, z_raw);
    }

    return 0;
}

/**
 * @brief Enable accelerometer in fast mode
 * Reading will be decreased to 8 bits, therefore resolution decreases
 * @return 0 on success, error status on error
 */
int Accelerometer::enable_in_fast_mode()
{   
    disable();

    // Write new configuration
    uint8_t config = 0b00001111;
    if (i2c->write(address, CTRL_REG1, &config, 1) == PICO_ERROR_GENERIC) {
        return ACC_ERROR_STATUS;
    }
    fast_mode = true;

    sleep_ms(10);

    return 0;
}

/**
 * @brief Enable accelerometer in normal mode
 * @return 0 on success, error status on error
 */
int Accelerometer::enable()
{
    disable();

    uint8_t config = 0b00001101;
    if (i2c->write(address, CTRL_REG1, &config, 1) == PICO_ERROR_GENERIC) {
        return ACC_ERROR_STATUS;
    }
    fast_mode = false;
    
    sleep_ms(10);

    return 0;
}

/**
 * @brief Disable accelerometer
 * @return 0 on success, error status on error
 */
int Accelerometer::disable()
{
    // Set control register to read values in Xmsb, Ymsb, Zmsb order
    uint8_t config = 0b00001000;
    if (i2c->write(address, CTRL_REG1, &config, 1) == PICO_ERROR_GENERIC) {
        return ACC_ERROR_STATUS;
    }

    sleep_ms(10);
    
    return 0;
}

/**
 * @brief Enable orientation interrupt
 * This will set the needed configuration for
 * orientation embedded functionality
 * Iterrupt will set INT2 pin to HIGH when orientation is changed
 * @return 0 on success, error status on error
 */
int Accelerometer::enable_orientation_interrupt()
{
    disable();

    uint8_t config;

    // Enable embedded orientation detection function
    config = 0b10000000;
    if (i2c->write(address, PL_CFG, &config, 1) == PICO_ERROR_GENERIC) {
        return ACC_ERROR_STATUS;
    } 
    sleep_ms(5);

    // Enable orientation interrupt
    // By default, interrupt is routed to pin INT2
    config = 0b00010000;
    if (i2c->write(address, CTRL_REG4, &config, 1) == PICO_ERROR_GENERIC) {
        return ACC_ERROR_STATUS;
    }
    sleep_ms(5);

    return 0;
}

/**
 * @brief Acknowledge interrupt generated by the function.
 * Clear status bits.
 * Read orientation.
 * @return Orientation success, error status on error
 */
int Accelerometer::get_orientation()
{
    uint8_t orientation;
    if (i2c->read(address, PL_STATUS, &orientation, 1) == PICO_ERROR_GENERIC) {
        return ACC_ERROR_STATUS;
    }
    sleep_ms(5);

    return orientation;
}

/**
 * @brief Fetch raw data from the device
 * @return Number of bytes read
 */
int Accelerometer::fetch_data()
{
    if (fast_mode) {
        printf("Fast mode reading.\n");
        return i2c->read(address, OUT_X_MSB, buffer_short, XYZ_BUFFER);
    }
    else {
        printf("Slow mode reading.\n");
        return i2c->read(address, OUT_X_MSB, buffer_full, XYZ_BUFFER_FULL);
    }
}